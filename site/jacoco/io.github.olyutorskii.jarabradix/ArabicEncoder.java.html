<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ArabicEncoder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JarabraDix</a> &gt; <a href="index.source.html" class="el_package">io.github.olyutorskii.jarabradix</a> &gt; <span class="el_source">ArabicEncoder.java</span></div><h1>ArabicEncoder.java</h1><pre class="source lang-java linenums">/*
 * License : The MIT License
 * Copyright(c) 2017 olyutorskii
 */

package io.github.olyutorskii.jarabradix;

/**
 * Convert integer value to Arabic-decimal character sequence.
 *
 * &lt;p&gt;It's similar to {@link java.lang.Integer#toString(int)}
 * but, GC-friendly.
 *
 * &lt;p&gt;char buffer grows towards a younger index.
 *
 * @see &lt;a target=&quot;_blank&quot;
 * href=&quot;https://en.wikipedia.org/wiki/Division_algorithm#Division_by_a_constant&quot;&gt;
 * Division by a constant (Wikipedia)
 * &lt;/a&gt;
 */
<span class="pc bpc" id="L21" title="1 of 2 branches missed.">public final class ArabicEncoder {</span>

    /** Required char-array length to convert any int value. */
    public static final int MINLEN_INT  = 11;

    /** Required char-array length to convert any long value. */
    public static final int MINLEN_LONG = 20;

    private static final String MINTXT_INT  =          &quot;-2147483648&quot;;
    private static final String MINTXT_LONG = &quot;-9223372036854775808&quot;;

    private static final int DECA = 10;
    private static final long UINT_MAX = (1L &lt;&lt; 32) - 1L;  //  4294967295L

    private static final int CHUNKUNIT = DECA * DECA;
    private static final int CHUNKLIMIT = 65536;

    private static final int DIV10SFT = 19;        // 2^19 = 524288
    private static final int DIV10NUME = 52429;    // near equal 524288 / 10

    private static final int ARABICUC_MASK = 0b0011_0000;

    private static final char[] HECT1;
    private static final char[] HECT0;


    static{
<span class="pc bpc" id="L48" title="2 of 4 branches missed.">        assert MINTXT_INT .equals(Integer.toString(Integer.MIN_VALUE));</span>
<span class="pc bpc" id="L49" title="2 of 4 branches missed.">        assert MINTXT_LONG.equals(Long   .toString(Long   .MIN_VALUE));</span>
<span class="pc bpc" id="L50" title="2 of 4 branches missed.">        assert MINLEN_INT  == MINTXT_INT .length();</span>
<span class="pc bpc" id="L51" title="2 of 4 branches missed.">        assert MINLEN_LONG == MINTXT_LONG.length();</span>

<span class="fc" id="L53">        HECT1 = new char[CHUNKUNIT];</span>
<span class="fc" id="L54">        HECT0 = new char[CHUNKUNIT];</span>
<span class="fc bfc" id="L55" title="All 2 branches covered.">        for(int idx = 0; idx &lt; CHUNKUNIT; idx++){</span>
<span class="fc" id="L56">            final int h1 = idx / DECA;</span>
<span class="fc" id="L57">            final int h0 = idx % DECA;</span>
<span class="fc" id="L58">            HECT1[idx] = Character.forDigit(h1, DECA);</span>
<span class="fc" id="L59">            HECT0[idx] = Character.forDigit(h0, DECA);</span>
        }
    }

    static{
        assert CHUNKLIMIT &gt;= CHUNKUNIT / DECA;
        assert (long)(CHUNKLIMIT - 1) * (long)DIV10NUME &lt;= UINT_MAX;

        assert DIV10NUME - ((1 &lt;&lt; DIV10SFT) / DECA) &lt;= 1;

        assert ( 1         * DIV10NUME) &gt;&gt;&gt; DIV10SFT == 0;
        assert ((DECA - 1) * DIV10NUME) &gt;&gt;&gt; DIV10SFT == 0;
        assert ( DECA      * DIV10NUME) &gt;&gt;&gt; DIV10SFT == 1;
        assert ((CHUNKLIMIT - 1) * DIV10NUME) &gt;&gt;&gt; DIV10SFT
            ==  (CHUNKLIMIT - 1) / DECA;

<span class="pc bpc" id="L75" title="2 of 4 branches missed.">        assert Character.forDigit(9, DECA) == (ARABICUC_MASK | 9);</span>
<span class="fc" id="L76">    }</span>


    /**
     * Hidden constructor.
     */
<span class="nc" id="L82">    private ArabicEncoder(){</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">        assert false;</span>
<span class="nc" id="L84">    }</span>


    /**
     * Convert int value to Arabic-decimal sequence.
     *
     * &lt;p&gt;Result will be aligned to the last array position.
     *
     * @param iVal int value
     * @param cbuf char buffer array output
     * @return stored digits sequence (and sign) length
     * @throws IndexOutOfBoundsException too small array
     * @see java.lang.Integer#toString(int)
     */
    public static int int2Arabic(final int iVal, final char[] cbuf)
            throws IndexOutOfBoundsException{
<span class="fc" id="L100">        int lastPos = cbuf.length - 1;</span>
<span class="fc" id="L101">        return int2Arabic(iVal, cbuf, lastPos);</span>
    }

    /**
     * Convert int value to Arabic-decimal sequence.
     *
     * &lt;p&gt;Result will be aligned to the specified tail position.
     *
     * @param iVal int value
     * @param cbuf char buffer array output
     * @param lastPos index of tail position in array
     * @return stored digits sequence (and sign) length
     * @throws IndexOutOfBoundsException invalid position
     * @see java.lang.Integer#toString(int)
     */
    public static int int2Arabic(
            final int iVal,
            final char[] cbuf,
            final int lastPos
    )
            throws IndexOutOfBoundsException{
<span class="fc bfc" id="L122" title="All 2 branches covered.">        if(iVal == Integer.MIN_VALUE){</span>
<span class="fc" id="L123">            return cramIntMin(cbuf, lastPos);</span>
        }

<span class="fc bfc" id="L126" title="All 2 branches covered.">        final boolean negative = iVal &lt; 0;</span>
<span class="fc" id="L127">        int cidx = lastPos;</span>
        int absVal32;
        int div32;

<span class="fc bfc" id="L131" title="All 2 branches covered.">        if(negative){</span>
<span class="fc" id="L132">            absVal32 = -iVal;</span>
        }else{
<span class="fc" id="L134">            absVal32 =  iVal;</span>
        }

<span class="fc bfc" id="L137" title="All 2 branches covered.">        while(absVal32 &gt;= CHUNKLIMIT){</span>
<span class="fc" id="L138">            div32         = absVal32 / CHUNKUNIT;</span>
<span class="fc" id="L139">            final int mod = absVal32 % CHUNKUNIT;</span>
<span class="fc" id="L140">            absVal32 = div32;</span>

<span class="fc" id="L142">            cbuf[cidx--] = HECT0[mod];</span>
<span class="fc" id="L143">            cbuf[cidx--] = HECT1[mod];</span>
<span class="fc" id="L144">        }</span>

        do{
<span class="fc" id="L147">            div32 = (absVal32 * DIV10NUME) &gt;&gt;&gt; DIV10SFT;</span>
            //  div32 = abs32 * 52429 / 524288
            //        = floor(abs32 * 0.1000003814697265625);
            //        = abs32 / 10;

<span class="fc" id="L152">            final int mod = absVal32 % DECA;</span>
<span class="fc" id="L153">            absVal32 = div32;</span>

<span class="fc" id="L155">            cbuf[cidx--] = (char)(mod | ARABICUC_MASK);</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">        }while(div32 &gt; 0);</span>

<span class="fc bfc" id="L158" title="All 2 branches covered.">        if(negative) cbuf[cidx--] = '-';</span>

<span class="fc" id="L160">        final int result = lastPos - cidx;</span>

<span class="fc" id="L162">        return result;</span>
    }

    /**
     * Convert long value to Arabic-decimal sequence.
     *
     * &lt;p&gt;Result will be aligned to the last array position.
     *
     * @param lVal long value
     * @param cbuf char buffer array output
     * @return stored digits sequence (and sign) length
     * @throws IndexOutOfBoundsException too small array
     * @see java.lang.Long#toString(long)
     */
    public static int long2Arabic(final long lVal, final char[] cbuf)
            throws IndexOutOfBoundsException{
<span class="fc" id="L178">        int lastPos = cbuf.length - 1;</span>
<span class="fc" id="L179">        return long2Arabic(lVal, cbuf, lastPos);</span>
    }

    /**
     * Convert long value to Arabic-decimal sequence.
     *
     * &lt;p&gt;Result will be aligned to the specified tail position.
     *
     * @param lVal long value
     * @param cbuf char buffer array output
     * @param lastPos index of tail position in array
     * @return stored digits sequence (and sign) length
     * @throws IndexOutOfBoundsException invalid position
     * @see java.lang.Long#toString(long)
     */
    public static int long2Arabic(
            final long lVal,
            final char[] cbuf,
            final int lastPos
    )
            throws IndexOutOfBoundsException{
<span class="fc bfc" id="L200" title="All 2 branches covered.">        if(lVal == Long.MIN_VALUE){</span>
<span class="fc" id="L201">            return cramLongMin(cbuf, lastPos);</span>
        }

<span class="fc bfc" id="L204" title="All 2 branches covered.">        final boolean negative = lVal &lt; 0L;</span>
<span class="fc" id="L205">        int cidx = lastPos;</span>
        long absVal64;
        long div64;

<span class="fc bfc" id="L209" title="All 2 branches covered.">        if(negative){</span>
<span class="fc" id="L210">            absVal64 = -lVal;</span>
        }else{
<span class="fc" id="L212">            absVal64 =  lVal;</span>
        }

<span class="fc bfc" id="L215" title="All 2 branches covered.">        while(absVal64 &gt; Integer.MAX_VALUE){</span>
<span class="fc" id="L216">            div64         =       absVal64 / CHUNKUNIT;</span>
<span class="fc" id="L217">            final int mod = (int)(absVal64 % CHUNKUNIT);</span>
<span class="fc" id="L218">            absVal64 = div64;</span>

<span class="fc" id="L220">            cbuf[cidx--] = HECT0[mod];</span>
<span class="fc" id="L221">            cbuf[cidx--] = HECT1[mod];</span>
<span class="fc" id="L222">        }</span>

<span class="fc" id="L224">        int absVal32 = (int) absVal64;</span>
        int div32;

<span class="fc bfc" id="L227" title="All 2 branches covered.">        while(absVal32 &gt;= CHUNKLIMIT){</span>
<span class="fc" id="L228">            div32         = absVal32 / CHUNKUNIT;</span>
<span class="fc" id="L229">            final int mod = absVal32 % CHUNKUNIT;</span>
<span class="fc" id="L230">            absVal32 = div32;</span>

<span class="fc" id="L232">            cbuf[cidx--] = HECT0[mod];</span>
<span class="fc" id="L233">            cbuf[cidx--] = HECT1[mod];</span>
<span class="fc" id="L234">        }</span>

        do{
<span class="fc" id="L237">            div32 = (absVal32 * DIV10NUME) &gt;&gt;&gt; DIV10SFT;</span>
            //  div32 = abs32 * 52429 / 524288
            //        = floor(abs32 * 0.1000003814697265625);
            //        = abs32 / 10;

<span class="fc" id="L242">            final int mod = absVal32 % DECA;</span>
<span class="fc" id="L243">            absVal32 = div32;</span>

<span class="fc" id="L245">            cbuf[cidx--] = (char)(mod | ARABICUC_MASK);</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">        }while(div32 &gt; 0);</span>

<span class="fc bfc" id="L248" title="All 2 branches covered.">        if(negative) cbuf[cidx--] = '-';</span>

<span class="fc" id="L250">        final int result = lastPos - cidx;</span>

<span class="fc" id="L252">        return result;</span>
    }

    /**
     * Store int minimum digits to char array.
     *
     * @param cbuf char buffer
     * @param lastPos index of tail position
     * @return digits (and sign) length
     * @throws IndexOutOfBoundsException invalid position
     * @see java.lang.Integer#MIN_VALUE
     */
    private static int cramIntMin(final char[] cbuf, final int lastPos)
            throws IndexOutOfBoundsException{
<span class="fc" id="L266">        final int startPos = lastPos - (MINLEN_INT - 1);</span>
<span class="fc" id="L267">        MINTXT_INT.getChars(0, MINLEN_INT, cbuf, startPos);</span>
<span class="fc" id="L268">        return MINLEN_INT;</span>
    }

    /**
     * Store long minimum digits to char array.
     *
     * @param cbuf char buffer
     * @param lastPos index of tail position
     * @return digits (and sign) length
     * @throws IndexOutOfBoundsException invalid position
     * @see java.lang.Long#MIN_VALUE
     */
    private static int cramLongMin(final char[] cbuf, final int lastPos)
            throws IndexOutOfBoundsException{
<span class="fc" id="L282">        final int startPos = lastPos - (MINLEN_LONG - 1);</span>
<span class="fc" id="L283">        MINTXT_LONG.getChars(0, MINLEN_LONG, cbuf, startPos);</span>
<span class="fc" id="L284">        return MINLEN_LONG;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>